{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar utils_1 = require(\"../utils\");\n\nvar groupby_1 = require(\"./groupby\");\n\nvar orderby_1 = require(\"./orderby\");\n\nvar limit_1 = require(\"./limit\");\n\nvar where_1 = require(\"./where\");\n\nvar VALID_AGGR_FUNCTIONS = ['MIN', 'MAX', 'SUM', 'AVG'];\n\nfunction select_(ref, ast, options) {\n  return __awaiter(this, void 0, void 0, function () {\n    var selectOp, queries, documents;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          selectOp = new SelectOperation(ref, ast, options);\n          queries = selectOp.generateQueries_();\n          return [4\n          /*yield*/\n          , selectOp.executeQueries_(queries)];\n\n        case 1:\n          documents = _a.sent();\n          return [2\n          /*return*/\n          , selectOp.processDocuments_(queries, documents)];\n      }\n    });\n  });\n}\n\nexports.select_ = select_;\n\nvar SelectOperation =\n/** @class */\nfunction () {\n  function SelectOperation(_ref, _ast, options) {\n    this._ref = _ref;\n    this._ast = _ast; // We need to determine if we have to include\n    // the document's ID (__name__) in the results.\n\n    this._includeId = options.includeId || false;\n\n    if (!this._includeId && Array.isArray(_ast.columns)) {\n      for (var i = 0; i < _ast.columns.length; i++) {\n        if (_ast.columns[i].expr.type === 'column_ref') {\n          if (_ast.columns[i].expr.column === utils_1.DOCUMENT_KEY_NAME) {\n            this._includeId = true;\n            break;\n          }\n        }\n      }\n    }\n\n    if (this._includeId === void 0) {\n      this._includeId = false;\n    }\n  }\n\n  SelectOperation.prototype.generateQueries_ = function (ast) {\n    ast = ast || this._ast;\n    utils_1.assert(ast.from.parts.length % 2 === 1, '\"FROM\" needs a path to a collection (odd number of parts).');\n    var path = ast.from.parts.join('/');\n    var queries = [];\n\n    if (ast.from.group) {\n      utils_1.assert(this._ref.path === '', 'Collection group queries are only allowed from the root of the database.');\n      var firestore = utils_1.contains(this._ref, 'firestore') ? this._ref.firestore : this._ref;\n      utils_1.assert(typeof firestore.collectionGroup === 'function', \"Your version of the Firebase SDK doesn't support collection group queries.\");\n      queries.push(firestore.collectionGroup(path));\n    } else {\n      queries.push(this._ref.collection(path));\n    }\n    /*\n     * We'd need this if we end up implementing JOINs, but for now\n     * it's unnecessary since we're only querying a single collection\n    \n      // Keep track of aliased \"tables\" (collections)\n      const aliasedCollections: { [k: string]: string } = {};\n      if (ast.from[0].as.length > 0) {\n        aliasedCollections[ast.from[0].as] = colName;\n      } else {\n        aliasedCollections[colName] = colName;\n      }\n    */\n\n\n    if (ast.where) {\n      queries = where_1.applyWhere(queries, ast.where);\n    }\n\n    if (ast.orderby) {\n      queries = orderby_1.applyOrderBy(queries, ast.orderby);\n      /*\n       FIXME: the following query throws an error:\n          SELECT city, name\n          FROM restaurants\n          WHERE city IN ('Nashvile', 'Denver')\n          ORDER BY city, name\n                It happens because \"WHERE ... IN ...\" splits into 2 separate\n       queries with a \"==\" filter, and an order by clause cannot\n       contain a field with an equality filter:\n          ...where(\"city\",\"==\",\"Denver\").orderBy(\"city\")\n      */\n    } // if (ast.groupby) {\n    //   throw new Error('GROUP BY not supported yet');\n    // }\n\n\n    if (ast.limit) {\n      // First we apply the limit to each query we may have\n      // and later we'll apply it again locally to the\n      // merged set of documents, in case we end up with too many.\n      queries = limit_1.applyLimit(queries, ast.limit);\n    }\n\n    if (ast._next) {\n      utils_1.assert(ast._next.type === 'select', ' UNION statements are only supported between SELECTs.'); // This is the UNION of 2 SELECTs, so lets process the second\n      // one and merge their queries\n\n      queries = queries.concat(this.generateQueries_(ast._next)); // FIXME: The SQL parser incorrectly attributes ORDER BY to the second\n      // SELECT only, instead of to the whole UNION. Find a workaround.\n    }\n\n    return queries;\n  };\n\n  SelectOperation.prototype.executeQueries_ = function (queries) {\n    return __awaiter(this, void 0, void 0, function () {\n      var documents, seenDocuments, err_1;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            documents = [];\n            seenDocuments = {};\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , Promise.all(queries.map(function (query) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var snapshot, numDocs, i, docSnap, docPath, docData;\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      return [4\n                      /*yield*/\n                      , query.get()];\n\n                    case 1:\n                      snapshot = _a.sent();\n                      numDocs = snapshot.docs.length;\n\n                      for (i = 0; i < numDocs; i++) {\n                        docSnap = snapshot.docs[i];\n                        docPath = docSnap.ref.path;\n\n                        if (!utils_1.contains(seenDocuments, docPath)) {\n                          docData = docSnap.data();\n\n                          if (this._includeId) {\n                            docData[typeof this._includeId === 'string' ? this._includeId : utils_1.DOCUMENT_KEY_NAME] = docSnap.id;\n                          }\n\n                          documents.push(docData);\n                          seenDocuments[docPath] = true;\n                        }\n                      }\n\n                      return [2\n                      /*return*/\n                      ];\n                  }\n                });\n              });\n            }))];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            err_1 = _a.sent(); // TODO: handle error?\n\n            throw err_1;\n\n          case 4:\n            return [2\n            /*return*/\n            , documents];\n        }\n      });\n    });\n  };\n\n  SelectOperation.prototype.processDocuments_ = function (queries, documents) {\n    if (documents.length === 0) {\n      return [];\n    } else {\n      if (this._ast.groupby) {\n        var groupedDocs = groupby_1.applyGroupByLocally(documents, this._ast.groupby);\n        return this._processGroupedDocs(queries, groupedDocs);\n      } else {\n        return this._processUngroupedDocs(queries, documents);\n      }\n    }\n  };\n\n  SelectOperation.prototype._processUngroupedDocs = function (queries, documents) {\n    var _this = this;\n\n    if (this._ast.orderby && queries.length > 1) {\n      // We merged more than one query into a single set of documents\n      // so we need to order the documents again, this time client-side.\n      documents = orderby_1.applyOrderByLocally(documents, this._ast.orderby);\n    }\n\n    if (this._ast.limit && queries.length > 1) {\n      // We merged more than one query into a single set of documents\n      // so we need to apply the limit again, this time client-side.\n      documents = limit_1.applyLimitLocally(documents, this._ast.limit);\n    }\n\n    if (typeof this._ast.columns === 'string' && this._ast.columns === '*') {// Return all fields from the documents\n    } else if (Array.isArray(this._ast.columns)) {\n      var aggrColumns = getAggrColumns(this._ast.columns);\n\n      if (aggrColumns.length > 0) {\n        var docsGroup = new groupby_1.DocumentsGroup();\n        docsGroup.documents = documents;\n        aggregateDocuments(docsGroup, aggrColumns); /// Since there is no GROUP BY and we already computed all\n        // necessary aggregated values, at this point we only care\n        // about the first document in the list. Anything else is\n        // irrelevant.\n\n        var resultEntry = this._buildResultEntry(docsGroup.documents[0], docsGroup.aggr);\n\n        documents = [resultEntry];\n      } else {\n        documents = documents.map(function (doc) {\n          return _this._buildResultEntry(doc);\n        });\n      }\n    } else {\n      // We should never reach here\n      throw new Error('Internal error (ast.columns).');\n    }\n\n    return documents;\n  };\n\n  SelectOperation.prototype._processGroupedDocs = function (queries, groupedDocs) {\n    var _this = this;\n\n    utils_1.assert(this._ast.columns !== '*', 'Cannot \"SELECT *\" when using GROUP BY.');\n    var aggrColumns = getAggrColumns(this._ast.columns);\n    var groups = flattenGroupedDocs(groupedDocs);\n\n    if (aggrColumns.length === 0) {\n      // We're applying a GROUP BY but none of the fields requested\n      // in the SELECT are an aggregate function. In this case we\n      // just return an entry for the first document.\n      var firstGroupKey = Object.keys(groups)[0];\n      var firstGroup = groups[firstGroupKey];\n      var firstDoc = firstGroup.documents[0];\n      return [this._buildResultEntry(firstDoc)];\n    } else {\n      var results_1 = []; // TODO: ORDER BY\n\n      utils_1.assert(!this._ast.orderby, 'ORDER BY is not yet supported when using GROUP BY.'); // TODO: LIMIT\n\n      utils_1.assert(!this._ast.limit, 'LIMIT is not yet supported when using GROUP BY.');\n      Object.keys(groups).forEach(function (groupKey) {\n        var docsGroup = groups[groupKey];\n        aggregateDocuments(docsGroup, aggrColumns);\n\n        var resultEntry = _this._buildResultEntry(docsGroup.documents[0], docsGroup.aggr);\n\n        results_1.push(resultEntry);\n      });\n      return results_1;\n    }\n  };\n\n  SelectOperation.prototype._buildResultEntry = function (document, aggregate, asFieldArray) {\n    if (asFieldArray === void 0) {\n      asFieldArray = false;\n    }\n\n    var idIncluded = false;\n    var columns = this._ast.columns;\n    var resultFields = columns.reduce(function (entries, column) {\n      var fieldName;\n      var fieldAlias;\n\n      switch (column.expr.type) {\n        case 'column_ref':\n          fieldName = column.expr.column;\n          fieldAlias = utils_1.nameOrAlias(fieldName, column.as);\n          entries.push(new AliasedField(fieldName, fieldAlias, utils_1.deepGet(document, fieldName)));\n\n          if (fieldName === utils_1.DOCUMENT_KEY_NAME) {\n            idIncluded = true;\n          }\n\n          break;\n\n        case 'aggr_func':\n          vaidateAggrFunction(column.expr);\n          fieldName = column.expr.field;\n          fieldAlias = utils_1.nameOrAlias(fieldName, column.as, column.expr);\n          entries.push(new AliasedField(fieldName, fieldAlias, aggregate[column.expr.name.toLowerCase()][fieldName]));\n          break;\n\n        default:\n          throw new Error('Unsupported type in SELECT.');\n      }\n\n      return entries;\n    }, []);\n\n    if (this._includeId && !idIncluded) {\n      resultFields.push(new AliasedField(utils_1.DOCUMENT_KEY_NAME, typeof this._includeId === 'string' ? this._includeId : utils_1.DOCUMENT_KEY_NAME, utils_1.safeGet(document, utils_1.DOCUMENT_KEY_NAME)));\n    }\n\n    if (asFieldArray) {\n      return resultFields;\n    } else {\n      return resultFields.reduce(function (doc, field) {\n        doc[field.alias] = field.value;\n        return doc;\n      }, {});\n    }\n  };\n\n  return SelectOperation;\n}();\n\nexports.SelectOperation = SelectOperation;\n/*************************************************/\n\nfunction aggregateDocuments(docsGroup, functions) {\n  var numDocs = docsGroup.documents.length;\n\n  var _loop_1 = function _loop_1(i) {\n    var doc = docsGroup.documents[i]; // If the same field is used in more than one aggregate function\n    // we don't want to sum its value more than once.\n\n    var skipSum = {};\n    functions.forEach(function (fn) {\n      var value = utils_1.safeGet(doc, fn.field);\n      var isNumber = !Number.isNaN(value);\n\n      switch (fn.name) {\n        case 'AVG':\n          // Lets put a value so that later we know we have to compute this avg\n          docsGroup.aggr.avg[fn.field] = 0;\n        // tslint:disable-next-line:no-switch-case-fall-through\n\n        case 'SUM':\n          if (utils_1.safeGet(skipSum, fn.field) !== true) {\n            skipSum[fn.field] = true;\n\n            if (!utils_1.contains(docsGroup.aggr.total, fn.field)) {\n              docsGroup.aggr.total[fn.field] = 0;\n              docsGroup.aggr.sum[fn.field] = 0;\n            }\n\n            value = Number(value);\n            utils_1.assert(!Number.isNaN(value), \"Can't compute aggregate function \" + fn.name + \"(\" + fn.field + \") because some values are not numbers.\");\n            docsGroup.aggr.total[fn.field] += 1;\n            docsGroup.aggr.sum[fn.field] += value; // FIXME: if the numbers are big we could easily go out of bounds in this sum\n          }\n\n          break;\n\n        case 'MIN':\n          utils_1.assert(isNumber || typeof value === 'string', \"Aggregate function MIN(\" + fn.field + \") can only be performed on numbers or strings\");\n\n          if (!utils_1.contains(docsGroup.aggr.min, fn.field)) {\n            docsGroup.aggr.min[fn.field] = value;\n          } else {\n            if (!Number.isNaN(docsGroup.aggr.min[fn.field])) {\n              // The current minimum is a number\n              utils_1.assert(isNumber, \"Can't compute aggregate function MIN(\" + fn.field + \") because some values are not numbers.\");\n              value = Number(value);\n            }\n\n            if (value < docsGroup.aggr.min[fn.field]) {\n              docsGroup.aggr.min[fn.field] = value;\n            }\n          }\n\n          break;\n\n        case 'MAX':\n          utils_1.assert(isNumber || typeof value === 'string', \"Aggregate function MAX(\" + fn.field + \") can only be performed on numbers or strings\");\n\n          if (!utils_1.contains(docsGroup.aggr.max, fn.field)) {\n            docsGroup.aggr.max[fn.field] = value;\n          } else {\n            if (!Number.isNaN(docsGroup.aggr.max[fn.field])) {\n              // The current maximum is a number\n              utils_1.assert(isNumber, \"Can't compute aggregate function MAX(\" + fn.field + \") because some values are not numbers.\");\n              value = Number(value);\n            }\n\n            if (value > docsGroup.aggr.max[fn.field]) {\n              docsGroup.aggr.max[fn.field] = value;\n            }\n          }\n\n          break;\n      }\n    });\n  };\n\n  for (var i = 0; i < numDocs; i++) {\n    _loop_1(i);\n  } // Compute any necessary averages\n\n\n  Object.keys(docsGroup.aggr.avg).forEach(function (group) {\n    docsGroup.aggr.avg[group] = docsGroup.aggr.sum[group] / docsGroup.aggr.total[group];\n  });\n  return docsGroup;\n}\n\nfunction getAggrColumns(columns) {\n  var aggrColumns = [];\n\n  if (columns !== '*') {\n    columns.forEach(function (astColumn) {\n      if (astColumn.expr.type === 'aggr_func') {\n        vaidateAggrFunction(astColumn.expr);\n        aggrColumns.push(astColumn.expr);\n      } else {\n        utils_1.assert(astColumn.expr.type === 'column_ref', 'Only field names and aggregate functions are supported in SELECT statements.');\n      }\n    });\n  }\n\n  return aggrColumns;\n}\n\nfunction vaidateAggrFunction(aggrFn) {\n  // TODO: support COUNT, then remove this assert\n  utils_1.assert(aggrFn.name !== 'COUNT', 'Aggregate function COUNT is not yet supported.');\n  utils_1.assert(VALID_AGGR_FUNCTIONS.includes(aggrFn.name), \"Unknown aggregate function '\" + aggrFn.name + \"'.\");\n  utils_1.assert( // tslint:disable-next-line: strict-type-predicates\n  typeof aggrFn.field === 'string', \"Unsupported type in aggregate function '\" + aggrFn.name + \"'.\");\n}\n\nfunction flattenGroupedDocs(groupedDocs) {\n  var result = {};\n\n  for (var prop in groupedDocs) {\n    if (!utils_1.contains(groupedDocs, prop)) {\n      continue;\n    }\n\n    if (!(groupedDocs[prop] instanceof groupby_1.DocumentsGroup)) {\n      var flatInner = flattenGroupedDocs(groupedDocs[prop]);\n\n      for (var innerProp in flatInner) {\n        if (!utils_1.contains(flatInner, innerProp)) {\n          continue;\n        }\n\n        result[prop + '$$' + innerProp] = flatInner[innerProp];\n      }\n    } else {\n      result[prop] = groupedDocs[prop];\n    }\n  }\n\n  return result;\n}\n/**\n * Represents a field (prop) in a document.\n * It stores the original field name, the assigned alias, and the value.\n *\n * This is necessary in order to properly apply ORDER BY once\n * a result set has been built.\n */\n\n\nvar AliasedField =\n/** @class */\nfunction () {\n  function AliasedField(name, alias, value) {\n    this.name = name;\n    this.alias = alias;\n    this.value = value;\n  }\n\n  return AliasedField;\n}();","map":{"version":3,"sources":["../../src/select/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"../utils\");\nvar groupby_1 = require(\"./groupby\");\nvar orderby_1 = require(\"./orderby\");\nvar limit_1 = require(\"./limit\");\nvar where_1 = require(\"./where\");\nvar VALID_AGGR_FUNCTIONS = ['MIN', 'MAX', 'SUM', 'AVG'];\nfunction select_(ref, ast, options) {\n    return __awaiter(this, void 0, void 0, function () {\n        var selectOp, queries, documents;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    selectOp = new SelectOperation(ref, ast, options);\n                    queries = selectOp.generateQueries_();\n                    return [4 /*yield*/, selectOp.executeQueries_(queries)];\n                case 1:\n                    documents = _a.sent();\n                    return [2 /*return*/, selectOp.processDocuments_(queries, documents)];\n            }\n        });\n    });\n}\nexports.select_ = select_;\nvar SelectOperation = /** @class */ (function () {\n    function SelectOperation(_ref, _ast, options) {\n        this._ref = _ref;\n        this._ast = _ast;\n        // We need to determine if we have to include\n        // the document's ID (__name__) in the results.\n        this._includeId = options.includeId || false;\n        if (!this._includeId && Array.isArray(_ast.columns)) {\n            for (var i = 0; i < _ast.columns.length; i++) {\n                if (_ast.columns[i].expr.type === 'column_ref') {\n                    if (_ast.columns[i].expr.column === utils_1.DOCUMENT_KEY_NAME) {\n                        this._includeId = true;\n                        break;\n                    }\n                }\n            }\n        }\n        if (this._includeId === void 0) {\n            this._includeId = false;\n        }\n    }\n    SelectOperation.prototype.generateQueries_ = function (ast) {\n        ast = ast || this._ast;\n        utils_1.assert(ast.from.parts.length % 2 === 1, '\"FROM\" needs a path to a collection (odd number of parts).');\n        var path = ast.from.parts.join('/');\n        var queries = [];\n        if (ast.from.group) {\n            utils_1.assert(this._ref.path === '', 'Collection group queries are only allowed from the root of the database.');\n            var firestore = utils_1.contains(this._ref, 'firestore')\n                ? this._ref.firestore\n                : this._ref;\n            utils_1.assert(typeof firestore.collectionGroup === 'function', \"Your version of the Firebase SDK doesn't support collection group queries.\");\n            queries.push(firestore.collectionGroup(path));\n        }\n        else {\n            queries.push(this._ref.collection(path));\n        }\n        /*\n         * We'd need this if we end up implementing JOINs, but for now\n         * it's unnecessary since we're only querying a single collection\n        \n          // Keep track of aliased \"tables\" (collections)\n          const aliasedCollections: { [k: string]: string } = {};\n          if (ast.from[0].as.length > 0) {\n            aliasedCollections[ast.from[0].as] = colName;\n          } else {\n            aliasedCollections[colName] = colName;\n          }\n       */\n        if (ast.where) {\n            queries = where_1.applyWhere(queries, ast.where);\n        }\n        if (ast.orderby) {\n            queries = orderby_1.applyOrderBy(queries, ast.orderby);\n            /*\n             FIXME: the following query throws an error:\n                SELECT city, name\n                FROM restaurants\n                WHERE city IN ('Nashvile', 'Denver')\n                ORDER BY city, name\n        \n             It happens because \"WHERE ... IN ...\" splits into 2 separate\n             queries with a \"==\" filter, and an order by clause cannot\n             contain a field with an equality filter:\n                ...where(\"city\",\"==\",\"Denver\").orderBy(\"city\")\n            */\n        }\n        // if (ast.groupby) {\n        //   throw new Error('GROUP BY not supported yet');\n        // }\n        if (ast.limit) {\n            // First we apply the limit to each query we may have\n            // and later we'll apply it again locally to the\n            // merged set of documents, in case we end up with too many.\n            queries = limit_1.applyLimit(queries, ast.limit);\n        }\n        if (ast._next) {\n            utils_1.assert(ast._next.type === 'select', ' UNION statements are only supported between SELECTs.');\n            // This is the UNION of 2 SELECTs, so lets process the second\n            // one and merge their queries\n            queries = queries.concat(this.generateQueries_(ast._next));\n            // FIXME: The SQL parser incorrectly attributes ORDER BY to the second\n            // SELECT only, instead of to the whole UNION. Find a workaround.\n        }\n        return queries;\n    };\n    SelectOperation.prototype.executeQueries_ = function (queries) {\n        return __awaiter(this, void 0, void 0, function () {\n            var documents, seenDocuments, err_1;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        documents = [];\n                        seenDocuments = {};\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, Promise.all(queries.map(function (query) { return __awaiter(_this, void 0, void 0, function () {\n                                var snapshot, numDocs, i, docSnap, docPath, docData;\n                                return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                        case 0: return [4 /*yield*/, query.get()];\n                                        case 1:\n                                            snapshot = _a.sent();\n                                            numDocs = snapshot.docs.length;\n                                            for (i = 0; i < numDocs; i++) {\n                                                docSnap = snapshot.docs[i];\n                                                docPath = docSnap.ref.path;\n                                                if (!utils_1.contains(seenDocuments, docPath)) {\n                                                    docData = docSnap.data();\n                                                    if (this._includeId) {\n                                                        docData[typeof this._includeId === 'string'\n                                                            ? this._includeId\n                                                            : utils_1.DOCUMENT_KEY_NAME] = docSnap.id;\n                                                    }\n                                                    documents.push(docData);\n                                                    seenDocuments[docPath] = true;\n                                                }\n                                            }\n                                            return [2 /*return*/];\n                                    }\n                                });\n                            }); }))];\n                    case 2:\n                        _a.sent();\n                        return [3 /*break*/, 4];\n                    case 3:\n                        err_1 = _a.sent();\n                        // TODO: handle error?\n                        throw err_1;\n                    case 4: return [2 /*return*/, documents];\n                }\n            });\n        });\n    };\n    SelectOperation.prototype.processDocuments_ = function (queries, documents) {\n        if (documents.length === 0) {\n            return [];\n        }\n        else {\n            if (this._ast.groupby) {\n                var groupedDocs = groupby_1.applyGroupByLocally(documents, this._ast.groupby);\n                return this._processGroupedDocs(queries, groupedDocs);\n            }\n            else {\n                return this._processUngroupedDocs(queries, documents);\n            }\n        }\n    };\n    SelectOperation.prototype._processUngroupedDocs = function (queries, documents) {\n        var _this = this;\n        if (this._ast.orderby && queries.length > 1) {\n            // We merged more than one query into a single set of documents\n            // so we need to order the documents again, this time client-side.\n            documents = orderby_1.applyOrderByLocally(documents, this._ast.orderby);\n        }\n        if (this._ast.limit && queries.length > 1) {\n            // We merged more than one query into a single set of documents\n            // so we need to apply the limit again, this time client-side.\n            documents = limit_1.applyLimitLocally(documents, this._ast.limit);\n        }\n        if (typeof this._ast.columns === 'string' && this._ast.columns === '*') {\n            // Return all fields from the documents\n        }\n        else if (Array.isArray(this._ast.columns)) {\n            var aggrColumns = getAggrColumns(this._ast.columns);\n            if (aggrColumns.length > 0) {\n                var docsGroup = new groupby_1.DocumentsGroup();\n                docsGroup.documents = documents;\n                aggregateDocuments(docsGroup, aggrColumns);\n                /// Since there is no GROUP BY and we already computed all\n                // necessary aggregated values, at this point we only care\n                // about the first document in the list. Anything else is\n                // irrelevant.\n                var resultEntry = this._buildResultEntry(docsGroup.documents[0], docsGroup.aggr);\n                documents = [resultEntry];\n            }\n            else {\n                documents = documents.map(function (doc) { return _this._buildResultEntry(doc); });\n            }\n        }\n        else {\n            // We should never reach here\n            throw new Error('Internal error (ast.columns).');\n        }\n        return documents;\n    };\n    SelectOperation.prototype._processGroupedDocs = function (queries, groupedDocs) {\n        var _this = this;\n        utils_1.assert(this._ast.columns !== '*', 'Cannot \"SELECT *\" when using GROUP BY.');\n        var aggrColumns = getAggrColumns(this._ast.columns);\n        var groups = flattenGroupedDocs(groupedDocs);\n        if (aggrColumns.length === 0) {\n            // We're applying a GROUP BY but none of the fields requested\n            // in the SELECT are an aggregate function. In this case we\n            // just return an entry for the first document.\n            var firstGroupKey = Object.keys(groups)[0];\n            var firstGroup = groups[firstGroupKey];\n            var firstDoc = firstGroup.documents[0];\n            return [this._buildResultEntry(firstDoc)];\n        }\n        else {\n            var results_1 = [];\n            // TODO: ORDER BY\n            utils_1.assert(!this._ast.orderby, 'ORDER BY is not yet supported when using GROUP BY.');\n            // TODO: LIMIT\n            utils_1.assert(!this._ast.limit, 'LIMIT is not yet supported when using GROUP BY.');\n            Object.keys(groups).forEach(function (groupKey) {\n                var docsGroup = groups[groupKey];\n                aggregateDocuments(docsGroup, aggrColumns);\n                var resultEntry = _this._buildResultEntry(docsGroup.documents[0], docsGroup.aggr);\n                results_1.push(resultEntry);\n            });\n            return results_1;\n        }\n    };\n    SelectOperation.prototype._buildResultEntry = function (document, aggregate, asFieldArray) {\n        if (asFieldArray === void 0) { asFieldArray = false; }\n        var idIncluded = false;\n        var columns = this._ast.columns;\n        var resultFields = columns.reduce(function (entries, column) {\n            var fieldName;\n            var fieldAlias;\n            switch (column.expr.type) {\n                case 'column_ref':\n                    fieldName = column.expr.column;\n                    fieldAlias = utils_1.nameOrAlias(fieldName, column.as);\n                    entries.push(new AliasedField(fieldName, fieldAlias, utils_1.deepGet(document, fieldName)));\n                    if (fieldName === utils_1.DOCUMENT_KEY_NAME) {\n                        idIncluded = true;\n                    }\n                    break;\n                case 'aggr_func':\n                    vaidateAggrFunction(column.expr);\n                    fieldName = column.expr.field;\n                    fieldAlias = utils_1.nameOrAlias(fieldName, column.as, column.expr);\n                    entries.push(new AliasedField(fieldName, fieldAlias, aggregate[column.expr.name.toLowerCase()][fieldName]));\n                    break;\n                default:\n                    throw new Error('Unsupported type in SELECT.');\n            }\n            return entries;\n        }, []);\n        if (this._includeId && !idIncluded) {\n            resultFields.push(new AliasedField(utils_1.DOCUMENT_KEY_NAME, typeof this._includeId === 'string'\n                ? this._includeId\n                : utils_1.DOCUMENT_KEY_NAME, utils_1.safeGet(document, utils_1.DOCUMENT_KEY_NAME)));\n        }\n        if (asFieldArray) {\n            return resultFields;\n        }\n        else {\n            return resultFields.reduce(function (doc, field) {\n                doc[field.alias] = field.value;\n                return doc;\n            }, {});\n        }\n    };\n    return SelectOperation;\n}());\nexports.SelectOperation = SelectOperation;\n/*************************************************/\nfunction aggregateDocuments(docsGroup, functions) {\n    var numDocs = docsGroup.documents.length;\n    var _loop_1 = function (i) {\n        var doc = docsGroup.documents[i];\n        // If the same field is used in more than one aggregate function\n        // we don't want to sum its value more than once.\n        var skipSum = {};\n        functions.forEach(function (fn) {\n            var value = utils_1.safeGet(doc, fn.field);\n            var isNumber = !Number.isNaN(value);\n            switch (fn.name) {\n                case 'AVG':\n                    // Lets put a value so that later we know we have to compute this avg\n                    docsGroup.aggr.avg[fn.field] = 0;\n                // tslint:disable-next-line:no-switch-case-fall-through\n                case 'SUM':\n                    if (utils_1.safeGet(skipSum, fn.field) !== true) {\n                        skipSum[fn.field] = true;\n                        if (!utils_1.contains(docsGroup.aggr.total, fn.field)) {\n                            docsGroup.aggr.total[fn.field] = 0;\n                            docsGroup.aggr.sum[fn.field] = 0;\n                        }\n                        value = Number(value);\n                        utils_1.assert(!Number.isNaN(value), \"Can't compute aggregate function \" + fn.name + \"(\" + fn.field + \") because some values are not numbers.\");\n                        docsGroup.aggr.total[fn.field] += 1;\n                        docsGroup.aggr.sum[fn.field] += value;\n                        // FIXME: if the numbers are big we could easily go out of bounds in this sum\n                    }\n                    break;\n                case 'MIN':\n                    utils_1.assert(isNumber || typeof value === 'string', \"Aggregate function MIN(\" + fn.field + \") can only be performed on numbers or strings\");\n                    if (!utils_1.contains(docsGroup.aggr.min, fn.field)) {\n                        docsGroup.aggr.min[fn.field] = value;\n                    }\n                    else {\n                        if (!Number.isNaN(docsGroup.aggr.min[fn.field])) {\n                            // The current minimum is a number\n                            utils_1.assert(isNumber, \"Can't compute aggregate function MIN(\" + fn.field + \") because some values are not numbers.\");\n                            value = Number(value);\n                        }\n                        if (value < docsGroup.aggr.min[fn.field]) {\n                            docsGroup.aggr.min[fn.field] = value;\n                        }\n                    }\n                    break;\n                case 'MAX':\n                    utils_1.assert(isNumber || typeof value === 'string', \"Aggregate function MAX(\" + fn.field + \") can only be performed on numbers or strings\");\n                    if (!utils_1.contains(docsGroup.aggr.max, fn.field)) {\n                        docsGroup.aggr.max[fn.field] = value;\n                    }\n                    else {\n                        if (!Number.isNaN(docsGroup.aggr.max[fn.field])) {\n                            // The current maximum is a number\n                            utils_1.assert(isNumber, \"Can't compute aggregate function MAX(\" + fn.field + \") because some values are not numbers.\");\n                            value = Number(value);\n                        }\n                        if (value > docsGroup.aggr.max[fn.field]) {\n                            docsGroup.aggr.max[fn.field] = value;\n                        }\n                    }\n                    break;\n            }\n        });\n    };\n    for (var i = 0; i < numDocs; i++) {\n        _loop_1(i);\n    }\n    // Compute any necessary averages\n    Object.keys(docsGroup.aggr.avg).forEach(function (group) {\n        docsGroup.aggr.avg[group] =\n            docsGroup.aggr.sum[group] / docsGroup.aggr.total[group];\n    });\n    return docsGroup;\n}\nfunction getAggrColumns(columns) {\n    var aggrColumns = [];\n    if (columns !== '*') {\n        columns.forEach(function (astColumn) {\n            if (astColumn.expr.type === 'aggr_func') {\n                vaidateAggrFunction(astColumn.expr);\n                aggrColumns.push(astColumn.expr);\n            }\n            else {\n                utils_1.assert(astColumn.expr.type === 'column_ref', 'Only field names and aggregate functions are supported in SELECT statements.');\n            }\n        });\n    }\n    return aggrColumns;\n}\nfunction vaidateAggrFunction(aggrFn) {\n    // TODO: support COUNT, then remove this assert\n    utils_1.assert(aggrFn.name !== 'COUNT', 'Aggregate function COUNT is not yet supported.');\n    utils_1.assert(VALID_AGGR_FUNCTIONS.includes(aggrFn.name), \"Unknown aggregate function '\" + aggrFn.name + \"'.\");\n    utils_1.assert(\n    // tslint:disable-next-line: strict-type-predicates\n    typeof aggrFn.field === 'string', \"Unsupported type in aggregate function '\" + aggrFn.name + \"'.\");\n}\nfunction flattenGroupedDocs(groupedDocs) {\n    var result = {};\n    for (var prop in groupedDocs) {\n        if (!utils_1.contains(groupedDocs, prop)) {\n            continue;\n        }\n        if (!(groupedDocs[prop] instanceof groupby_1.DocumentsGroup)) {\n            var flatInner = flattenGroupedDocs(groupedDocs[prop]);\n            for (var innerProp in flatInner) {\n                if (!utils_1.contains(flatInner, innerProp)) {\n                    continue;\n                }\n                result[prop + '$$' + innerProp] = flatInner[innerProp];\n            }\n        }\n        else {\n            result[prop] = groupedDocs[prop];\n        }\n    }\n    return result;\n}\n/**\n * Represents a field (prop) in a document.\n * It stores the original field name, the assigned alias, and the value.\n *\n * This is necessary in order to properly apply ORDER BY once\n * a result set has been built.\n */\nvar AliasedField = /** @class */ (function () {\n    function AliasedField(name, alias, value) {\n        this.name = name;\n        this.alias = alias;\n        this.value = value;\n    }\n    return AliasedField;\n}());\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}