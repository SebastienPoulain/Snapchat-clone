{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DOCUMENT_KEY_NAME = '__name__';\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nexports.assert = assert;\n\nfunction contains(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nexports.contains = contains;\n\nfunction safeGet(obj, prop) {\n  if (contains(obj, prop)) return obj[prop];\n}\n\nexports.safeGet = safeGet;\n\nfunction deepGet(obj, path) {\n  var value = obj;\n  var props = path.split('.');\n  props.some(function (prop) {\n    value = safeGet(value, prop); // By using \"some\" instead of \"forEach\", we can return\n    // true whenever we want to break out of the loop.\n\n    return typeof value === void 0;\n  });\n  return value;\n}\n\nexports.deepGet = deepGet;\n\nfunction astValueToNative(astValue) {\n  var value;\n\n  switch (astValue.type) {\n    case 'bool':\n    case 'null':\n    case 'string':\n      value = astValue.value;\n      break;\n\n    case 'number':\n      value = Number(astValue.value);\n      break;\n\n    default:\n      throw new Error('Unsupported value type in WHERE clause.');\n  }\n\n  return value;\n}\n\nexports.astValueToNative = astValueToNative;\n/**\n * Adapted from: https://github.com/firebase/firebase-ios-sdk/blob/14dd9dc2704038c3bf702426439683cee4dc941a/Firestore/core/src/firebase/firestore/util/string_util.cc#L23-L40\n */\n\nfunction prefixSuccessor(prefix) {\n  // We can increment the last character in the string and be done\n  // unless that character is 255 (0xff), in which case we have to erase the\n  // last character and increment the previous character, unless that\n  // is 255, etc. If the string is empty or consists entirely of\n  // 255's, we just return the empty string.\n  var limit = prefix;\n\n  while (limit.length > 0) {\n    var index = limit.length - 1;\n\n    if (limit[index] === '\\xff') {\n      limit = limit.slice(0, -1);\n    } else {\n      limit = limit.substr(0, index) + String.fromCharCode(limit.charCodeAt(index) + 1);\n      break;\n    }\n  }\n\n  return limit;\n}\n\nexports.prefixSuccessor = prefixSuccessor;\n\nfunction nameOrAlias(name, alias, aggrFn) {\n  if (alias !== null && alias.length > 0) {\n    return alias;\n  }\n\n  if (!aggrFn) {\n    return name;\n  }\n\n  return aggrFn.name + \"(\" + name + \")\";\n}\n\nexports.nameOrAlias = nameOrAlias;","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":";;;;;AAMa,OAAA,CAAA,iBAAA,GAAoB,UAApB;;AAEb,SAAgB,MAAhB,CAAuB,SAAvB,EAA2C,OAA3C,EAA0D;AACxD,MAAI,CAAC,SAAL,EAAgB;AACd,UAAM,IAAI,KAAJ,CAAU,OAAV,CAAN;AACD;AACF;;AAJD,OAAA,CAAA,MAAA,GAAA,MAAA;;AAMA,SAAgB,QAAhB,CAAyB,GAAzB,EAAsC,IAAtC,EAAkD;AAChD,SAAO,MAAM,CAAC,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,GAArC,EAA0C,IAA1C,CAAP;AACD;;AAFD,OAAA,CAAA,QAAA,GAAA,QAAA;;AAIA,SAAgB,OAAhB,CAAwB,GAAxB,EAAkC,IAAlC,EAA8C;AAC5C,MAAI,QAAQ,CAAC,GAAD,EAAM,IAAN,CAAZ,EAAyB,OAAO,GAAG,CAAC,IAAD,CAAV;AAC1B;;AAFD,OAAA,CAAA,OAAA,GAAA,OAAA;;AAIA,SAAgB,OAAhB,CAAwB,GAAxB,EAAkC,IAAlC,EAA8C;AAC5C,MAAI,KAAK,GAAG,GAAZ;AACA,MAAM,KAAK,GAAG,IAAI,CAAC,KAAL,CAAW,GAAX,CAAd;AAEA,EAAA,KAAK,CAAC,IAAN,CAAW,UAAA,IAAA,EAAI;AACb,IAAA,KAAK,GAAG,OAAO,CAAC,KAAD,EAAQ,IAAR,CAAf,CADa,CAGb;AACA;;AACA,WAAO,OAAO,KAAP,KAAiB,KAAK,CAA7B;AACD,GAND;AAQA,SAAO,KAAP;AACD;;AAbD,OAAA,CAAA,OAAA,GAAA,OAAA;;AAeA,SAAgB,gBAAhB,CACE,QADF,EACqB;AAEnB,MAAI,KAAJ;;AAEA,UAAQ,QAAQ,CAAC,IAAjB;AACE,SAAK,MAAL;AACA,SAAK,MAAL;AACA,SAAK,QAAL;AACE,MAAA,KAAK,GAAG,QAAQ,CAAC,KAAjB;AACA;;AACF,SAAK,QAAL;AACE,MAAA,KAAK,GAAG,MAAM,CAAC,QAAQ,CAAC,KAAV,CAAd;AACA;;AACF;AACE,YAAM,IAAI,KAAJ,CAAU,yCAAV,CAAN;AAVJ;;AAaA,SAAO,KAAP;AACD;;AAnBD,OAAA,CAAA,gBAAA,GAAA,gBAAA;AAoBA;;AAEG;;AACH,SAAgB,eAAhB,CAAgC,MAAhC,EAA8C;AAC5C;AACA;AACA;AACA;AACA;AACA,MAAI,KAAK,GAAG,MAAZ;;AACA,SAAO,KAAK,CAAC,MAAN,GAAe,CAAtB,EAAyB;AACvB,QAAM,KAAK,GAAG,KAAK,CAAC,MAAN,GAAe,CAA7B;;AACA,QAAI,KAAK,CAAC,KAAD,CAAL,KAAiB,MAArB,EAA6B;AAC3B,MAAA,KAAK,GAAG,KAAK,CAAC,KAAN,CAAY,CAAZ,EAAe,CAAC,CAAhB,CAAR;AACD,KAFD,MAEO;AACL,MAAA,KAAK,GACH,KAAK,CAAC,MAAN,CAAa,CAAb,EAAgB,KAAhB,IACA,MAAM,CAAC,YAAP,CAAoB,KAAK,CAAC,UAAN,CAAiB,KAAjB,IAA0B,CAA9C,CAFF;AAGA;AACD;AACF;;AACD,SAAO,KAAP;AACD;;AAnBD,OAAA,CAAA,eAAA,GAAA,eAAA;;AAqBA,SAAgB,WAAhB,CACE,IADF,EAEE,KAFF,EAGE,MAHF,EAG2B;AAEzB,MAAI,KAAK,KAAK,IAAV,IAAkB,KAAK,CAAC,MAAN,GAAe,CAArC,EAAwC;AACtC,WAAO,KAAP;AACD;;AAED,MAAI,CAAC,MAAL,EAAa;AACX,WAAO,IAAP;AACD;;AAED,SAAU,MAAM,CAAC,IAAP,GAAW,GAAX,GAAe,IAAf,GAAmB,GAA7B;AACD;;AAdD,OAAA,CAAA,WAAA,GAAA,WAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DOCUMENT_KEY_NAME = '__name__';\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message);\n    }\n}\nexports.assert = assert;\nfunction contains(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\nexports.contains = contains;\nfunction safeGet(obj, prop) {\n    if (contains(obj, prop))\n        return obj[prop];\n}\nexports.safeGet = safeGet;\nfunction deepGet(obj, path) {\n    var value = obj;\n    var props = path.split('.');\n    props.some(function (prop) {\n        value = safeGet(value, prop);\n        // By using \"some\" instead of \"forEach\", we can return\n        // true whenever we want to break out of the loop.\n        return typeof value === void 0;\n    });\n    return value;\n}\nexports.deepGet = deepGet;\nfunction astValueToNative(astValue) {\n    var value;\n    switch (astValue.type) {\n        case 'bool':\n        case 'null':\n        case 'string':\n            value = astValue.value;\n            break;\n        case 'number':\n            value = Number(astValue.value);\n            break;\n        default:\n            throw new Error('Unsupported value type in WHERE clause.');\n    }\n    return value;\n}\nexports.astValueToNative = astValueToNative;\n/**\n * Adapted from: https://github.com/firebase/firebase-ios-sdk/blob/14dd9dc2704038c3bf702426439683cee4dc941a/Firestore/core/src/firebase/firestore/util/string_util.cc#L23-L40\n */\nfunction prefixSuccessor(prefix) {\n    // We can increment the last character in the string and be done\n    // unless that character is 255 (0xff), in which case we have to erase the\n    // last character and increment the previous character, unless that\n    // is 255, etc. If the string is empty or consists entirely of\n    // 255's, we just return the empty string.\n    var limit = prefix;\n    while (limit.length > 0) {\n        var index = limit.length - 1;\n        if (limit[index] === '\\xff') {\n            limit = limit.slice(0, -1);\n        }\n        else {\n            limit =\n                limit.substr(0, index) +\n                    String.fromCharCode(limit.charCodeAt(index) + 1);\n            break;\n        }\n    }\n    return limit;\n}\nexports.prefixSuccessor = prefixSuccessor;\nfunction nameOrAlias(name, alias, aggrFn) {\n    if (alias !== null && alias.length > 0) {\n        return alias;\n    }\n    if (!aggrFn) {\n        return name;\n    }\n    return aggrFn.name + \"(\" + name + \")\";\n}\nexports.nameOrAlias = nameOrAlias;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}