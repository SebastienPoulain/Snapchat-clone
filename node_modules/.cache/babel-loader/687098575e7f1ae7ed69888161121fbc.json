{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = require(\"rxjs\");\n\nvar operators_1 = require(\"rxjs/operators\");\n\nvar firestore_1 = require(\"rxfire/firestore\");\n\nvar sql_parser_1 = require(\"../sql-parser\");\n\nvar firesql_1 = require(\"../firesql\");\n\nvar select_1 = require(\"../select\");\n\nvar utils_1 = require(\"../utils\");\n\nfiresql_1.FireSQL.prototype.rxQuery = function (sql, options) {\n  utils_1.assert( // tslint:disable-next-line: strict-type-predicates\n  typeof sql === 'string' && sql.length > 0, 'rxQuery() expects a non-empty string.');\n  var ast = sql_parser_1.parse(sql);\n  utils_1.assert(ast.type === 'select', 'Only SELECT statements are supported.');\n  return rxSelect(this._ref, ast, __assign({}, this._options, options));\n};\n\nfunction rxSelect(ref, ast, options) {\n  var selectOp = new select_1.SelectOperation(ref, ast, options);\n  var queries = selectOp.generateQueries_();\n\n  if (ast._next) {\n    utils_1.assert(ast._next.type === 'select', ' UNION statements are only supported between SELECTs.'); // This is the UNION of 2 SELECTs, so lets process the second\n    // one and merge their queries\n\n    queries = queries.concat(selectOp.generateQueries_(ast._next)); // FIXME: The SQL parser incorrectly attributes ORDER BY to the second\n    // SELECT only, instead of to the whole UNION. Find a workaround.\n  }\n\n  var idField;\n  var keepIdField;\n\n  if (selectOp._includeId === true) {\n    idField = utils_1.DOCUMENT_KEY_NAME;\n    keepIdField = true;\n  } else if (typeof selectOp._includeId === 'string') {\n    idField = selectOp._includeId;\n    keepIdField = true;\n  } else {\n    idField = utils_1.DOCUMENT_KEY_NAME;\n    keepIdField = false;\n  }\n\n  var rxData = rxjs_1.combineLatest(queries.map(function (query) {\n    return firestore_1.collectionData(query, idField);\n  }));\n  return rxData.pipe(operators_1.map(function (results) {\n    // We have an array of results (one for each query we generated) where\n    // each element is an array of documents. We need to flatten them.\n    var documents = [];\n    var seenDocuments = {};\n\n    for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {\n      var docs = results_1[_i];\n\n      for (var _a = 0, docs_1 = docs; _a < docs_1.length; _a++) {\n        var doc = docs_1[_a]; // Note: for now we're only allowing to query a single collection, but\n        // if at any point we change that (for example with JOINs) we'll need to\n        // use the full document path here instead of just its ID\n\n        if (!utils_1.contains(seenDocuments, doc[idField])) {\n          seenDocuments[doc[idField]] = true;\n\n          if (!keepIdField) {\n            delete doc[idField];\n          }\n\n          documents.push(doc);\n        }\n      }\n    }\n\n    return documents;\n  }), operators_1.map(function (documents) {\n    return selectOp.processDocuments_(queries, documents);\n  }));\n}","map":{"version":3,"sources":["../../src/rx/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar operators_1 = require(\"rxjs/operators\");\nvar firestore_1 = require(\"rxfire/firestore\");\nvar sql_parser_1 = require(\"../sql-parser\");\nvar firesql_1 = require(\"../firesql\");\nvar select_1 = require(\"../select\");\nvar utils_1 = require(\"../utils\");\nfiresql_1.FireSQL.prototype.rxQuery = function (sql, options) {\n    utils_1.assert(\n    // tslint:disable-next-line: strict-type-predicates\n    typeof sql === 'string' && sql.length > 0, 'rxQuery() expects a non-empty string.');\n    var ast = sql_parser_1.parse(sql);\n    utils_1.assert(ast.type === 'select', 'Only SELECT statements are supported.');\n    return rxSelect(this._ref, ast, __assign({}, this._options, options));\n};\nfunction rxSelect(ref, ast, options) {\n    var selectOp = new select_1.SelectOperation(ref, ast, options);\n    var queries = selectOp.generateQueries_();\n    if (ast._next) {\n        utils_1.assert(ast._next.type === 'select', ' UNION statements are only supported between SELECTs.');\n        // This is the UNION of 2 SELECTs, so lets process the second\n        // one and merge their queries\n        queries = queries.concat(selectOp.generateQueries_(ast._next));\n        // FIXME: The SQL parser incorrectly attributes ORDER BY to the second\n        // SELECT only, instead of to the whole UNION. Find a workaround.\n    }\n    var idField;\n    var keepIdField;\n    if (selectOp._includeId === true) {\n        idField = utils_1.DOCUMENT_KEY_NAME;\n        keepIdField = true;\n    }\n    else if (typeof selectOp._includeId === 'string') {\n        idField = selectOp._includeId;\n        keepIdField = true;\n    }\n    else {\n        idField = utils_1.DOCUMENT_KEY_NAME;\n        keepIdField = false;\n    }\n    var rxData = rxjs_1.combineLatest(queries.map(function (query) {\n        return firestore_1.collectionData(query, idField);\n    }));\n    return rxData.pipe(operators_1.map(function (results) {\n        // We have an array of results (one for each query we generated) where\n        // each element is an array of documents. We need to flatten them.\n        var documents = [];\n        var seenDocuments = {};\n        for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {\n            var docs = results_1[_i];\n            for (var _a = 0, docs_1 = docs; _a < docs_1.length; _a++) {\n                var doc = docs_1[_a];\n                // Note: for now we're only allowing to query a single collection, but\n                // if at any point we change that (for example with JOINs) we'll need to\n                // use the full document path here instead of just its ID\n                if (!utils_1.contains(seenDocuments, doc[idField])) {\n                    seenDocuments[doc[idField]] = true;\n                    if (!keepIdField) {\n                        delete doc[idField];\n                    }\n                    documents.push(doc);\n                }\n            }\n        }\n        return documents;\n    }), operators_1.map(function (documents) {\n        return selectOp.processDocuments_(queries, documents);\n    }));\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}