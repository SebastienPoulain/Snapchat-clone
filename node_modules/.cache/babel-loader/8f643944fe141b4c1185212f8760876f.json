{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar utils_1 = require(\"../utils\");\n\nfunction applyGroupByLocally(documents, astGroupBy) {\n  utils_1.assert(astGroupBy.length > 0, 'GROUP BY needs at least 1 group.');\n  var group = new DocumentsGroup();\n  group.documents = documents;\n  astGroupBy.forEach(function (groupBy) {\n    utils_1.assert(groupBy.type === 'column_ref', 'GROUP BY only supports grouping by field names.');\n    group = applySingleGroupBy(group, groupBy);\n  });\n  return group;\n}\n\nexports.applyGroupByLocally = applyGroupByLocally;\n\nfunction applySingleGroupBy(documents, groupBy) {\n  var groupedDocs = {};\n\n  if (documents instanceof DocumentsGroup) {\n    // We just have a list of documents\n    var numDocs = documents.documents.length;\n\n    for (var i = 0; i < numDocs; i++) {\n      var doc = documents.documents[i]; // Since we're going to use the value as an object key, always\n      // coherce it to a string in case it's some other type.\n\n      var groupValue = String(utils_1.safeGet(doc, groupBy.column));\n\n      if (!utils_1.contains(groupedDocs, groupValue)) {\n        groupedDocs[groupValue] = new DocumentsGroup();\n      }\n\n      groupedDocs[groupValue].documents.push(doc);\n    }\n\n    return groupedDocs;\n  } else {\n    // We have documents that have already been grouped with another field\n    var currentGroups = Object.keys(documents);\n    currentGroups.forEach(function (group) {\n      groupedDocs[group] = applySingleGroupBy(documents[group], groupBy);\n    });\n    return groupedDocs;\n  }\n}\n\nvar DocumentsGroup =\n/** @class */\nfunction () {\n  function DocumentsGroup(key) {\n    this.key = key;\n    this.documents = [];\n    this.aggr = {\n      sum: {},\n      avg: {},\n      min: {},\n      max: {},\n      total: {}\n    };\n  }\n\n  return DocumentsGroup;\n}();\n\nexports.DocumentsGroup = DocumentsGroup;","map":{"version":3,"sources":["../../src/select/groupby.ts"],"names":[],"mappings":";;;;;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAEA,SAAgB,mBAAhB,CACE,SADF,EAEE,UAFF,EAE2B;AAEzB,EAAA,OAAA,CAAA,MAAA,CAAO,UAAU,CAAC,MAAX,GAAoB,CAA3B,EAA8B,kCAA9B;AAEA,MAAI,KAAK,GAA8B,IAAI,cAAJ,EAAvC;AACA,EAAA,KAAK,CAAC,SAAN,GAAkB,SAAlB;AAEA,EAAA,UAAU,CAAC,OAAX,CAAmB,UAAA,OAAA,EAAO;AACxB,IAAA,OAAA,CAAA,MAAA,CACE,OAAO,CAAC,IAAR,KAAiB,YADnB,EAEE,iDAFF;AAIA,IAAA,KAAK,GAAG,kBAAkB,CAAC,KAAD,EAAQ,OAAR,CAA1B;AACD,GAND;AAQA,SAAQ,KAAR;AACD;;AAlBD,OAAA,CAAA,mBAAA,GAAA,mBAAA;;AAoBA,SAAS,kBAAT,CACE,SADF,EAEE,OAFF,EAEsB;AAEpB,MAAM,WAAW,GAAqB,EAAtC;;AAEA,MAAI,SAAS,YAAY,cAAzB,EAAyC;AACvC;AACA,QAAM,OAAO,GAAG,SAAS,CAAC,SAAV,CAAoB,MAApC;;AAEA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,OAApB,EAA6B,CAAC,EAA9B,EAAkC;AAChC,UAAM,GAAG,GAAG,SAAS,CAAC,SAAV,CAAoB,CAApB,CAAZ,CADgC,CAGhC;AACA;;AACA,UAAM,UAAU,GAAG,MAAM,CAAC,OAAA,CAAA,OAAA,CAAQ,GAAR,EAAa,OAAO,CAAC,MAArB,CAAD,CAAzB;;AAEA,UAAI,CAAC,OAAA,CAAA,QAAA,CAAS,WAAT,EAAsB,UAAtB,CAAL,EAAwC;AACtC,QAAA,WAAW,CAAC,UAAD,CAAX,GAA0B,IAAI,cAAJ,EAA1B;AACD;;AAEA,MAAA,WAAW,CAAC,UAAD,CAAX,CAA2C,SAA3C,CAAqD,IAArD,CAA0D,GAA1D;AACF;;AAED,WAAO,WAAP;AACD,GAnBD,MAmBO;AACL;AACA,QAAM,aAAa,GAAG,MAAM,CAAC,IAAP,CAAY,SAAZ,CAAtB;AACA,IAAA,aAAa,CAAC,OAAd,CAAsB,UAAA,KAAA,EAAK;AACzB,MAAA,WAAW,CAAC,KAAD,CAAX,GAAqB,kBAAkB,CAAC,SAAS,CAAC,KAAD,CAAV,EAAmB,OAAnB,CAAvC;AACD,KAFD;AAGA,WAAO,WAAP;AACD;AACF;;AAED,IAAA,cAAA;AAAA;AAAA,YAAA;AAUE,WAAA,cAAA,CAAmB,GAAnB,EAA+B;AAAZ,SAAA,GAAA,GAAA,GAAA;AATnB,SAAA,SAAA,GAA4B,EAA5B;AACA,SAAA,IAAA,GAA6B;AAC3B,MAAA,GAAG,EAAE,EADsB;AAE3B,MAAA,GAAG,EAAE,EAFsB;AAG3B,MAAA,GAAG,EAAE,EAHsB;AAI3B,MAAA,GAAG,EAAE,EAJsB;AAK3B,MAAA,KAAK,EAAE;AALoB,KAA7B;AAQmC;;AACrC,SAAA,cAAA;AAAC,CAXD,EAAA;;AAAa,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"../utils\");\nfunction applyGroupByLocally(documents, astGroupBy) {\n    utils_1.assert(astGroupBy.length > 0, 'GROUP BY needs at least 1 group.');\n    var group = new DocumentsGroup();\n    group.documents = documents;\n    astGroupBy.forEach(function (groupBy) {\n        utils_1.assert(groupBy.type === 'column_ref', 'GROUP BY only supports grouping by field names.');\n        group = applySingleGroupBy(group, groupBy);\n    });\n    return group;\n}\nexports.applyGroupByLocally = applyGroupByLocally;\nfunction applySingleGroupBy(documents, groupBy) {\n    var groupedDocs = {};\n    if (documents instanceof DocumentsGroup) {\n        // We just have a list of documents\n        var numDocs = documents.documents.length;\n        for (var i = 0; i < numDocs; i++) {\n            var doc = documents.documents[i];\n            // Since we're going to use the value as an object key, always\n            // coherce it to a string in case it's some other type.\n            var groupValue = String(utils_1.safeGet(doc, groupBy.column));\n            if (!utils_1.contains(groupedDocs, groupValue)) {\n                groupedDocs[groupValue] = new DocumentsGroup();\n            }\n            groupedDocs[groupValue].documents.push(doc);\n        }\n        return groupedDocs;\n    }\n    else {\n        // We have documents that have already been grouped with another field\n        var currentGroups = Object.keys(documents);\n        currentGroups.forEach(function (group) {\n            groupedDocs[group] = applySingleGroupBy(documents[group], groupBy);\n        });\n        return groupedDocs;\n    }\n}\nvar DocumentsGroup = /** @class */ (function () {\n    function DocumentsGroup(key) {\n        this.key = key;\n        this.documents = [];\n        this.aggr = {\n            sum: {},\n            avg: {},\n            min: {},\n            max: {},\n            total: {}\n        };\n    }\n    return DocumentsGroup;\n}());\nexports.DocumentsGroup = DocumentsGroup;\n//# sourceMappingURL=groupby.js.map"]},"metadata":{},"sourceType":"script"}